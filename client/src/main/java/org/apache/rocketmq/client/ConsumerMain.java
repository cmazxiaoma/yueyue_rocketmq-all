package org.apache.rocketmq.client;

/**
 * @author mayday_yueyue
 * @description RocketMQ消息消费
 * @date 2021-10-26 16:10
 */
public class ConsumerMain {

    /**
     * 1.消息队列负载与重新分布
     * 2.消息消费模式
     * 3.消息拉取方式
     * 4.消息进度反馈
     * 5.消息过滤
     * 6.顺序消息
     */

    /**
     * RocketMQ消息消费概述
     * 消息消费以组的模式开展，一个消费组内可以包含多个消费者，每隔消费组可以订阅多个主题
     * 消费组之间有集群模式与广播模式两种消费模式
     *
     * 集群模式，主题下的同一条消息只允许被其中一个消费者消费
     * 广播模式，主题下的同一条消息将被集群内的所有消费者消费一次
     *
     * 消费服务器与消费者之间的消息传达也有两种方式：推模式，拉模式
     *
     * 所谓的拉模式，是消费端主动发起拉消息请求，而推模式是消息到达消息服务器后，推给消息消费者
     * RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务
     *
     * 集群模式下，多个消费者如何对消息队列进行负载呢？
     * 消息队列负载机制遵循一个通用的思想，一个消息队列同一时间只允许被一个消费者消费，一个消费者可以消费多个队列
     *
     * RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。 不支持消息全局顺序消费
     *
     * 如果要实现某一主题的全局顺序消息消费，可以将该主题的队列数设置为1，牺牲高可用性
     *
     * RocketMQ支持两种消息过滤模式：表达式(TAG, SQL92)与类过滤模式
     *
     * 消息拉模式，主要是由客户端手动调用消息拉取API，而消息推模式是消息服务器主动将消息推送到消息消费端
     *
     */

    /**
     * 消息拉取基础流程
     *
     * 1.消息拉取客户端消息，拉取请求封装
     * 2.消息服务器查找并返回消息
     * 3.消息拉取客户端处理返回的消息
     */

    /**
     * 消息消费者在消费一批消息后，需要记录该批消息已经消费完毕，否则当消费者重新启动时
     * 又得从消息消费队列得开始消息，这显然是不能接受得
     *
     * 一次消息消费后，会从ProcessQueue处理队列中移除该批消息
     * 返回ProcessQueue最小偏移量，并存入消息进度表中
     *
     *  广播模式：同一个消费组的所有消息消费者都需要消费主题下的所有消息
     *  也就是同组内的消费者的消息消费行为是对立的，互不影响
     *  所以消息进度需要独立存储，最理想的存储地方应该与消费者绑定
     *
     *  集群模式: 同一个消费组内的所有消息消费者共享消息主题下的所有消息
     *  同一条消息（同一消息消费队列）在同一时间只会被消息组内的一个消费者消费
     *  并且随着消息队列的动态变化重新负载，所以消息进度需要保存在一个每个消费者都能访问到的地方
     */

    /**
     * RocketMQ消息拉取由PullMessageService与RebalanceService共同协作完成
     *
     *
     * PullMessageService                                       RebalanceService
     *          start                                                 start
     *          |                                                       |
     * pullRequestQueue.take()                                每隔20s进行一次队列负载
     *          |                                                      |
     * pullRequestQueue是否为空                              获取主题队列信息mqSet与消费组所有所有消费者cidAll
     *          |                                                      |
     * 消息拉取成功后将pullRequest加入到                        计算当前消费者分配到消息队列集合
     * pullRequestQueue，继续该队列的                                     |
     * 下一次消息拉取                                         如果新队列集合中不包含原先的队列，则停止原先队列消息消费并移除
     *                                                                 |
     *                                                     如果原先队列中不包含新分配队列，则创建PullRequest
     */


    /**
     * 顺序消息
     *
     * RocketMQ支持局部消息顺序消费，可以确保同一个消息消费队列中的消息被顺序消费，如果需要做到全局顺序消息则可以将主题配置成一个队列
     * 例如数据库BinLog等要求严格顺序场景，根据并发消息消费的流程，消息消费包含如下4个步骤：消息队列负载，消息拉取，消息消费，消息消费进度存储
     *
     *
     * RocketMQ首先需要通过RebalanceService线程实现消息队列的负载，集群模式下同一个消费组内的消费者共同承担其订阅主题下消息队列的消费
     * 同一个消息消费队列在同一时刻只会被消费组的一个消费者消费，一个消费者同一时刻可以分配多个消费队列
     */

    /**
     * RocketMQ消息消费
     *
     * 消息消费方式、消息拉取、消息消费进度存储、消息过滤、定时消息、顺序消息
     *
     * 消息队列负载由RebalanceService线程默认每隔20S进行一次消息队列负载，根据当前消费组内消费组个数与主题队列数量，按照某一种负载算法进行队列分配
     * 分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一时间只会分配给一个消费者
     *
     * 消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认一批拉取32条消息
     * 提交给消费者消费线程池后继续下一次的消息拉取，如果消息消费过慢产生消息推积，会触发消息消费拉取流控
     *
     * 并发消息消费是指消费线程池中的线程可以并发地对同一消息消费队列地消息进行消费，消费成功后，取出消息队列中最小地消息偏移量作为消息消费进度偏移量存在于消息消费进度存储文件中
     *
     * 集群模式消息进度在Broker, 广播模式消息进度存储在消费者端
     * 如果业务方返回RECONSUME_LATER,则RocketMQ启用消息消费重试机制，将原消息地主题与队列存储在消息属性中
     * 将消息存储在主题名为SCHEDULE_TOPIC_XXXX地消息消费队列中，等待指定时间后，RocketMQ将自动将该消息重新拉取并再次将消息存储在commitlog
     * 进而转发到原主题的消息消费队列供消费者消费，消息消费重试主题为%RETRY%消费者组名
     *
     * RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，比如1s 2s 5s等
     * 实现原理是RocketMQ为这些延迟级别定义对应的消息消费队列，其主题为SCHEDULE_TOPIC_XXXX
     * 然后创建对应延迟级别的定时任务从消息队列中将消息拉取，并恢复消息的原主题与消费队列，并再次存入commitlog转发到相应的消息消费队列，供消息消费者拉取消息并消费
     *
     * 顺序消息消费一般使用集群模式，是指消息消费者内的线程池对消息消费队列只能串行消费
     * 与并发消息消费最本质的区别是消费消息时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况
     *
     */
}
