package org.apache.rocketmq.client;

/**
 * @author mayday_yueyue
 * @description RocketMQ消息消费
 * @date 2021-10-26 16:10
 */
public class ConsumerMain {

    /**
     * 1.消息队列负载与重新分布
     * 2.消息消费模式
     * 3.消息拉取方式
     * 4.消息进度反馈
     * 5.消息过滤
     * 6.顺序消息
     */

    /**
     * RocketMQ消息消费概述
     * 消息消费以组的模式开展，一个消费组内可以包含多个消费者，每隔消费组可以订阅多个主题
     * 消费组之间有集群模式与广播模式两种消费模式
     *
     * 集群模式，主题下的同一条消息只允许被其中一个消费者消费
     * 广播模式，主题下的同一条消息将被集群内的所有消费者消费一次
     *
     * 消费服务器与消费者之间的消息传达也有两种方式：推模式，拉模式
     *
     * 所谓的拉模式，是消费端主动发起拉消息请求，而推模式是消息到达消息服务器后，推给消息消费者
     * RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务
     *
     * 集群模式下，多个消费者如何对消息队列进行负载呢？
     * 消息队列负载机制遵循一个通用的思想，一个消息队列同一时间只允许被一个消费者消费，一个消费者可以消费多个队列
     *
     * RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。 不支持消息全局顺序消费
     *
     * 如果要实现某一主题的全局顺序消息消费，可以将该主题的队列数设置为1，牺牲高可用性
     *
     * RocketMQ支持两种消息过滤模式：表达式(TAG, SQL92)与类过滤模式
     *
     * 消息拉模式，主要是由客户端手动调用消息拉取API，而消息推模式是消息服务器主动将消息推送到消息消费端
     *
     */

    /**
     * 消息拉取基础流程
     *
     * 1.消息拉取客户端消息，拉取请求封装
     * 2.消息服务器查找并返回消息
     * 3.消息拉取客户端处理返回的消息
     */

    /**
     * 消息消费者在消费一批消息后，需要记录该批消息已经消费完毕，否则当消费者重新启动时
     * 又得从消息消费队列得开始消息，这显然是不能接受得
     *
     * 一次消息消费后，会从ProcessQueue处理队列中移除该批消息
     * 返回ProcessQueue最小偏移量，并存入消息进度表中
     *
     *  广播模式：同一个消费组的所有消息消费者都需要消费主题下的所有消息
     *  也就是同组内的消费者的消息消费行为是对立的，互不影响
     *  所以消息进度需要独立存储，最理想的存储地方应该与消费者绑定
     *
     *  集群模式: 同一个消费组内的所有消息消费者共享消息主题下的所有消息
     *  同一条消息（同一消息消费队列）在同一时间只会被消息组内的一个消费者消费
     *  并且随着消息队列的动态变化重新负载，所以消息进度需要保存在一个每个消费者都能访问到的地方
     */
}
